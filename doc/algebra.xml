<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  algebra.xml           XModAlg documentation             Z. Arvasi  -->
<!--                                                        & A. Odabas  -->
<!--  Copyright (C) 2014-2021, Z. Arvasi & A. Odabas,              	 --> 
<!--  Osmangazi University, Eskisehir, Turkey                            --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<!-- lines to edit for each new version: 73, 121. --> 

<?xml version="1.0" encoding="UTF-8"?> 

<Chapter Label="Algebra">

<Heading>Algebras and their Actions</Heading>

All the algebras considered in this package will be associative 
and commutative. 
Scalars belong to a commutative ring <B>k</B> with <M>1 \neq 0</M>. 
<P/>
<E>Why not a field?  A group ring over the integers is not an algebra?</E>
<P/>

<Section>

<Heading>Commutative actions</Heading> 

If <M>S</M> and <M>R</M> are commutative <B>k</B>-algebras, a map 
<Display>
R \times S  ~\to~ S, 
\qquad 
(r,s)  ~\mapsto~  r \cdot s
</Display>
is a commutative action if and only if the following five axioms hold: 
<List>
<Item>
<M>k(r \cdot s) ~=~ (kr) \cdot s ~=~ r \cdot (ks)</M>, 
</Item>
<Item>
<M>r \cdot (s + s') ~=~ r \cdot s + r \cdot s', \qquad</M> 
(so <M>r \cdot 0_S = 0_S ~\forall~ r \in R</M>), 
</Item>
<Item>
<M>(r + r') \cdot s ~=~ r \cdot s + r' \cdot s, \qquad</M>  
(so <M>0_R \cdot s = 0_S ~\forall~ s \in S</M>), 
</Item>
<Item>
<M>r \cdot (ss') ~=~ (r \cdot s)s' = s(r \cdot s')</M>, 
</Item>
<Item>
<M>(rr') \cdot s ~=~ r \cdot (r' \cdot s), \qquad</M> 
(so <M>1_R \cdot s = s ~\forall~ s \in S</M> when <M>R</M> has a one), 
</Item>
</List>
for all <M>k \in </M><B>k</B>, <M>r,r' \in R</M>, and <M>s,s' \in S</M>. 
<P/> 

<ManSection>
   <Oper Name="AlgebraActionByMultiplication"
         Arg="A I" />
<Description>
When <M>I</M> is an ideal in <M>A</M> then multiplication is an action.  
In the example the algebra is the group ring of the cyclic group <M>C_6</M> 
over the field <M>GF(5)</M>. 
The ideal is generated by <M>v = () + (1,3,5)(2,4,6) + (1,5,3)(2,6,4)</M>. 
The generator <M>r = (1,2,3,4,5,6)</M> acts on <M>v</M> 
by multiplication to give the vector 
<M>r \cdot v = (1,2,3,4,5,6) + (1,4)(2,5)(3,6) + (1,6,5,4,3,2)</M>. 
</Description> 
</ManSection> 

<Example>
<![CDATA[
gap> A5c6 := GroupRing( GF(5), Group( (1,2,3,4,5,6) ) );;
gap> vecA := BasisVectors( Basis( A5c6 ) );; 
gap> v := vecA[1] + vecA[3] + vecA[5];
(Z(5)^0)*()+(Z(5)^0)*(1,3,5)(2,4,6)+(Z(5)^0)*(1,5,3)(2,6,4)
gap> I5c6 := Ideal( A5c6, [v] );; 
gap> act := AlgebraActionByMultiplication( A5c6, I5c6 );; 
gap> act2 := Image( act, vecA[2] );; 
gap> Image( act2, v );
(Z(5)^0)*(1,2,3,4,5,6)+(Z(5)^0)*(1,4)(2,5)(3,6)+(Z(5)^0)*(1,6,5,4,3,2)
]]>
</Example>


<!-- Add other actions here? -->


<ManSection>
   <Oper Name="SemidirectProductOfAlgebras"
         Arg="R act S" />
<Description>
When <M>R,S</M> are commutative algebras and <M>R</M> acts on <M>S</M> 
then we can form the semidirect product <M>R \ltimes S</M>, 
where the product is given by: 
<Display>
(r_1,s_1)(r_2,s_2) ~=~ (r_1r_2,~ r_1 \cdot s_2 + r_2 \cdot s_1 + s_1s_2). 
</Display> 

This product, as wekll as being commutative, is associative: 
<M>(r_1,s_1)(r_2,s_2)(r_3,s_3)</M> expands as: 
<Display>
(r_1r_2r_3,~ \left (r_1r_2)\cdot s3 + (r_1r_3)\cdot s_2 + (r_2r_3)\cdot s_1 
            + r_1 \cdot (s_2s_3) + r_2 \cdot (s_1s_3) + r_3 \cdot (s_1s_2) 
            + s_1s_2s_3 \right).
</Display> 

If <M>B_R, B_S</M> are the sets of basis vectors for <M>R</M> and <M>S</M> 
then <M>R \ltimes S</M> has basis 
<Display>
\{(r,0_S) ~|~ r \in B_R\} ~\cup~ \{(0_R,s) ~|~ s \in B_S\} 
</Display>
with defining products 
<Display>
(r_1,0_S)(r_2,0_S) = (r_1r_2,0_S), \qquad 
(r,0_S)(0_R,s) = (0_R,r \cdot s), \qquad 
(0_R,s_1)(0_R,s_2) = (0_R,s_1s_2). 
</Display>
Continuing the example above,
</Description> 
</ManSection> 

<Example>
<![CDATA[
gap> P := SemidirectProductOfAlgebras( A5c6, act, I5c6 ); 
gap> Embedding( P, 1 );
[ (Z(5)^0)*(), (Z(5)^0)*(1,2,3,4,5,6), (Z(5)^0)*(1,3,5)(2,4,6), 
  (Z(5)^0)*(1,4)(2,5)(3,6), (Z(5)^0)*(1,5,3)(2,6,4), (Z(5)^0)*(1,6,5,4,3,2) 
 ] -> [ v.1, v.2, v.3, v.4, v.5, v.6 ]
gap> Embedding( P, 2 );
[ (Z(5)^0)*()+(Z(5)^0)*(1,3,5)(2,4,6)+(Z(5)^0)*(1,5,3)(2,6,4), 
  (Z(5)^0)*(1,2,3,4,5,6)+(Z(5)^0)*(1,4)(2,5)(3,6)+(Z(5)^0)*(1,6,5,4,3,2) ] -> 
[ v.7, v.8 ]
gap> Projection( P, 1 );
[ v.1, v.2, v.3, v.4, v.5, v.6, v.7, v.8 ] -> 
[ (Z(5)^0)*(), (Z(5)^0)*(1,2,3,4,5,6), (Z(5)^0)*(1,3,5)(2,4,6), 
  (Z(5)^0)*(1,4)(2,5)(3,6), (Z(5)^0)*(1,5,3)(2,6,4), (Z(5)^0)*(1,6,5,4,3,2), 
  <zero> of ..., <zero> of ... ]
]]>
</Example> 

<ManSection>
   <Attr Name="SemidirectProductOfAlgebrasInfo"
         Arg="P" />
<Description>
The <C>SemidirectProductOfAlgebrasInfo(P)</C> for <M>P = R \ltimes S</M> 
is a record with fields <C>P.action</C>; <C>P.algebras</C>; 
<C>P.embeddings</C>; and <C>P.projections</C>. 
</Description> 
</ManSection> 

</Section>

<Section Label="algebra-homomorphism-lists">

<Heading>Lists of algebra homomorphisms</Heading> 

<ManSection>
   <Oper Name="AllAlgebraHomomorphisms"
         Arg="A B" />
   <Oper Name="AllBijectiveAlgebraHomomorphisms"
         Arg="A B" />
   <Oper Name="AllIdempotentAlgebraHomomorphisms"
         Arg="A B" />
<Description>
These three operations list all the homomorphisms from <M>A</M> to <M>B</M> 
of the specified type. 
These lists can get very long, so the operations should only be used with 
small algebras. 
</Description> 
</ManSection> 

<Example>
<![CDATA[
gap> A2c6 := GroupRing( GF(2), Group( (1,2,3,4,5,6) ) );;
gap> R2c3 := GroupRing( GF(2), Group( (7,8,9) ) );;
gap> homAR := AllAlgebraHomomorphisms( A2c6, R2c3 );;
gap> List( homAR, h -> MappingGeneratorsImages(h) );
[ [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ <zero> of ... ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ (Z(2)^0)*() ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ (Z(2)^0)*()+(Z(2)^0)*(7,8,9) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], 
      [ (Z(2)^0)*()+(Z(2)^0)*(7,8,9)+(Z(2)^0)*(7,9,8) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ (Z(2)^0)*()+(Z(2)^0)*(7,9,8) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ (Z(2)^0)*(7,8,9) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ (Z(2)^0)*(7,8,9)+(Z(2)^0)*(7,9,8) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ (Z(2)^0)*(7,9,8) ] ] ]
gap> homRA := AllAlgebraHomomorphisms( R2c3, A2c6 );;
gap> List( homRA, h -> MappingGeneratorsImages(h) );
[ [ [ (Z(2)^0)*(7,8,9) ], [ <zero> of ... ] ], 
  [ [ (Z(2)^0)*(7,8,9) ], [ (Z(2)^0)*() ] ], 
  [ [ (Z(2)^0)*(7,8,9) ], [ (Z(2)^0)*()+(Z(2)^0)*(1,3,5)(2,4,6) ] ], 
  [ [ (Z(2)^0)*(7,8,9) ], 
      [ (Z(2)^0)*()+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,5,3)(2,6,4) ] ], 
  [ [ (Z(2)^0)*(7,8,9) ], [ (Z(2)^0)*()+(Z(2)^0)*(1,5,3)(2,6,4) ] ], 
  [ [ (Z(2)^0)*(7,8,9) ], [ (Z(2)^0)*(1,3,5)(2,4,6) ] ], 
  [ [ (Z(2)^0)*(7,8,9) ], [ (Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,5,3)(2,6,4) ] 
     ], [ [ (Z(2)^0)*(7,8,9) ], [ (Z(2)^0)*(1,5,3)(2,6,4) ] ] ]
gap> bijAA := AllBijectiveAlgebraHomomorphisms( A2c6, A2c6 );;
gap> List( bijAA, h -> MappingGeneratorsImages(h) );
[ [ [ (Z(2)^0)*(1,6,5,4,3,2) ], 
      [ (Z(2)^0)*()+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,4)(2,5)(3,6) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], 
      [ (Z(2)^0)*()+(Z(2)^0)*(1,4)(2,5)(3,6)+(Z(2)^0)*(1,5,3)(2,6,4) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ (Z(2)^0)*(1,2,3,4,5,6) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], 
      [ (Z(2)^0)*(1,2,3,4,5,6)+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,5,3)
            (2,6,4) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], 
      [ (Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,5,3)(2,6,4)+(Z(2)^0)*
            (1,6,5,4,3,2) ] ], 
  [ [ (Z(2)^0)*(1,6,5,4,3,2) ], [ (Z(2)^0)*(1,6,5,4,3,2) ] ] ]
gap> ideAA := AllIdempotentAlgebraHomomorphisms( A2c6, A2c6 );; 
gap> Length( ideAA );
14
]]>
</Example>

</Section> 

</Chapter>
